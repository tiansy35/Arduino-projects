
#define BAUD 9600

/*
*********************************************************************************************************
** 函数名称 ：USART_init()
** 函数功能 ：串口初始化函数
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/
void USART_init()
{
  SREG = 0x80;                              //开启总中断
  //bitSet(UCSR0A,U2X0);
  bitSet(UCSR0B,RXCIE0);                    //允许接收完成中断 
  bitSet(UCSR0B,RXEN0);                     //开启接收功能 
  bitSet(UCSR0B,TXEN0);                     //开启发送功能 
  bitSet(UCSR0C,UCSZ01);
  bitSet(UCSR0C,UCSZ00);                    //设置异步通信，无奇偶校验，1个终止位，8位数据
  UBRR0=(F_CPU/16/BAUD-1);                  //波特率9600
}

/*
*********************************************************************************************************
** 函数名称 ：put_char()
** 函数功能 ：发送数据帧
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/ 
static void put_char(unsigned int data)  
{  
    if (data == '/r')  
        put_char(0x09);  
    while ( !(UCSR0A & (1<<UDRE0)) )    // 不为空，等之  
        ;  
    UDR0 = data;  
}  

/*
*********************************************************************************************************
** 函数名称 ：myprintf()
** 函数功能 ：自定义串口打印函数
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/ 
static void myprintf(const char* fmt,...)  
{  
    const char* s;  
    int d;  
    char buf[16];  
    va_list ap;  
    va_start(ap,fmt);   // 将ap指向fmt（即可变参数的第一个?下一个？）  
    while (*fmt)  
    {  
        if (*fmt != '%')  
        {  
            put_char(*fmt++);   // 正常发送  
            continue;     
        }  
        switch (*++fmt) // next %  
        {  
        case 's':  
            s = va_arg(ap,const char*); // 将ap指向者转成char*型，并返回之  
            for (; *s; s++)  
                put_char(*s);  
            break;  
        case 'x':  
            d = va_arg(ap,int);     // 将ap指向者转成int型，并返回之  
            itoa(d,buf,16);         // 将整型d以16进制转到buf中  
            for (s = buf; *s; s++)  
                put_char(*s);  
            break;  
        case 'd':  
            d = va_arg(ap,int);  
            itoa(d,buf,10);         // 将整型d以10进制转到buf中  
            for (s = buf; *s; s++)  
                put_char(*s);  
            break;  
        default:  
            put_char(*fmt);  
            break;  
        }  
        fmt++;  
    }  
    va_end(ap);  
}

/*
*********************************************************************************************************
** 函数名称 ：Sendbyte()
** 函数功能 ：串口发送一个字节
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/  
void Sendbyte(char c)
{
  loop_until_bit_is_set(UCSR0A,UDRE0);
  UDR0=c;
}

/*
*********************************************************************************************************
** 函数名称 ：ISR()
** 函数功能 ：串口中断
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/
//ISR(USART_RX_vect)                    //适合UNO
ISR(USART0_RX_vect)                     //适合MEGA 2560
{
  UCSR0B &= ~(1 << RXCIE0);         //关闭串口中断
  Get_uartdata(); 
  UCSR0B |=  (1 << RXCIE0);         //打开串口中断
}

/*
*********************************************************************************************************
** 函数名称 ：SendString()
** 函数功能 ：通过uart0发送字符串 ,并在结尾加上回车换行
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/
void SendString(char *str)
{
  while(*str)
  {
    Sendbyte(*str);
    str++;
  }
  Sendbyte(0x0d);
  Sendbyte(0x0a);  
}

/*
*********************************************************************************************************
** 函数名称 ：Get_uartdata()
** 函数功能 ：读取串口命令
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/
void Get_uartdata(void)
{
  static int i;
  serial_data = UDR0;//读取串口
  if (rec_flag == 0)
  {
    if (serial_data == 0xff)//第一次获取到0xff(即包头)
    {
      rec_flag = 1;
      i = 0;
      Costtime = 0;
    }
  }
  else
  {
    if (serial_data == 0xff)//第二次获取到0xff(即包尾)
    {
      rec_flag = 0;
      if (i == 3)//获取到中间数据为3个字节，说明此命令格式正确
      {
        Communication_Decode();//执行命令解析函数
      }
      i = 0;
    }
    else
    {
      buffer[i] = serial_data;//暂存数据
      i++;
    }
  }
}

/*
*********************************************************************************************************
** 函数名称 ：UartTimeoutCheck()
** 函数功能 ：串口超时检测
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/
void UartTimeoutCheck(void)
{
  if (rec_flag == 1)
  {
    Costtime++;
    if (Costtime == 100000)
    {
      rec_flag = 0;
    }
  }
}

/*
*********************************************************************************************************
** 函数名称 ：Communication_Decode()
** 函数功能 ：串口命令解码
** 入口参数 ：无
** 出口参数 ：无
*********************************************************************************************************
*/
void Communication_Decode()
{
  if (buffer[0] == 0x30)
  {
    switch (buffer[1])
    {
      case 0x00: mark = 0; flag = 0; return;  // if the first byte received is 0, the robot stops
      case 0x01: mark = 1; return;          // if the first byte received is 1, the robot moves
    }
  }
}
